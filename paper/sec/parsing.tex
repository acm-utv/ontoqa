\section{Parsing}
\label{sec:parsing}
% GIACOMO

The parsing process is responsible to generate a DUDES from a question expressed in natural language. 
%
To achieve this, it takes in input a \textit{SLTAG grammar} and a \textit{question} expresed in english natural language.
The output of the parsing process is a \textit{DUDES} representing the semantic of the question.
%
The produced DUDES will then be used to generate a \textit{SPARQL query}, that can be submitted to the ontology which the SLTAG grammar is aligned to.
%

\begin{algorithm}[t]
\SetKwProg{Fn}{Function}{}{}  

\Fn{receive (x,y,w)} {
	
	\If{$(x,y)\in E(G)$}{
		updateLink(x,y,w) \\
		$U \leftarrow update(x) \cup update(y)$ \\
		\For{$u\in U$}{
			emitHidden(u)\;
		}
	}
	
	\ElseIf{$x\in V(G) \land y\in V(G)$}{
		addLink(x,y,w) \\
		$U \leftarrow update(x) \cup update(y)$ \\
		\For{$u\in U$}{
			emitHidden(u)\;
			emitPotential(u)\;
		}
	}
	
	\ElseIf{$x\in V(G) \land y\notin V(G)$}{
		addLink(x,y,w) \\
		$U \leftarrow update(y)$ \\
		\For{$u\in U$}{
			emitHidden(u)\;
			emitPotential(u)\;
		}
	}
	
	\ElseIf{$x\notin V(G) \land y\in V(G)$}{
		addLink(x,y,w) \\
		$U \leftarrow update(x)$ \\
		\For{$u\in U$}{
			emitHidden(u)\;
			emitPotential(u)\;
		}
	}  
	
	\Else{
		addLink(x,y,w)
	}
}

\Fn{update (x)}{
	$N \leftarrow Neighbors(x)$ \\
	$U \leftarrow \emptyset$ \\
	\For{$y\in N$}{
		\If{$(x,y)\notin E(G)$}{
			$U \leftarrow U \cup \{(x,y)\}$
		}
	}
	\For{$z\in N$}{
		\If{$(x,z)\notin E(G) \land z\neq y$}{
			$U \leftarrow U \cup \{(y,z)\}$
		}
	}
	\KwResult{$U$}
}
\caption{Parsing algorithm}
\label{alg:parsing}
\end{algorithm}

Some functions in Algorithm~\ref{alg:parsing} have not been formally defined because they are pretty self-explanatory. 
For reader's sake, we briefly describe them here. \texttt{emitHidden(u)} and \texttt{emitPotential(u)} let the operator emit tuples in the form \texttt{(x,y,HIDDEN)} and \texttt{(x,y,POTENTIAL)}, meaning that an hidden or potential score update is necessary for the edge $(x,y)$, respectively.
\texttt{updateLink(x,y,w)} updates the existent edge $(x,y)$ with the new EWMA weight value. 
\texttt{addLink(x,y,w)} inserts the edge $(x,y)$ with weight $w$. 
\texttt{Neighbors(x)} return the set of neighbors of $x$.

\begin{algorithm}[t]
	\SetKwProg{Fn}{Function}{}{}  
	
	\Fn{receive (x,y,w)} {
		
		\If{$(x,y)\in E(G)$}{
			updateLink(x,y,w) \\
			$U \leftarrow update(x) \cup update(y)$ \\
			\For{$u\in U$}{
				emitHidden(u)\;
			}
		}
		
		\ElseIf{$x\in V(G) \land y\in V(G)$}{
			addLink(x,y,w) \\
			$U \leftarrow update(x) \cup update(y)$ \\
			\For{$u\in U$}{
				emitHidden(u)\;
				emitPotential(u)\;
			}
		}
		
		\ElseIf{$x\in V(G) \land y\notin V(G)$}{
			addLink(x,y,w) \\
			$U \leftarrow update(y)$ \\
			\For{$u\in U$}{
				emitHidden(u)\;
				emitPotential(u)\;
			}
		}
		
		\ElseIf{$x\notin V(G) \land y\in V(G)$}{
			addLink(x,y,w) \\
			$U \leftarrow update(x)$ \\
			\For{$u\in U$}{
				emitHidden(u)\;
				emitPotential(u)\;
			}
		}  
		
		\Else{
			addLink(x,y,w)
		}
	}
	
	\Fn{update (x)}{
		$N \leftarrow Neighbors(x)$ \\
		$U \leftarrow \emptyset$ \\
		\For{$y\in N$}{
			\If{$(x,y)\notin E(G)$}{
				$U \leftarrow U \cup \{(x,y)\}$
			}
		}
		\For{$z\in N$}{
			\If{$(x,z)\notin E(G) \land z\neq y$}{
				$U \leftarrow U \cup \{(y,z)\}$
			}
		}
		\KwResult{$U$}
	}
	\caption{Tokenization algorithm}
	\label{alg:tokenization}
\end{algorithm}

Some functions in Algorithm~\ref{alg:tokenization} have not been formally defined because they are pretty self-explanatory. 
For reader's sake, we briefly describe them here. \texttt{emitHidden(u)} and \texttt{emitPotential(u)} let the operator emit tuples in the form \texttt{(x,y,HIDDEN)} and \texttt{(x,y,POTENTIAL)}, meaning that an hidden or potential score update is necessary for the edge $(x,y)$, respectively.
\texttt{updateLink(x,y,w)} updates the existent edge $(x,y)$ with the new EWMA weight value. 
\texttt{addLink(x,y,w)} inserts the edge $(x,y)$ with weight $w$. 
\texttt{Neighbors(x)} return the set of neighbors of $x$.